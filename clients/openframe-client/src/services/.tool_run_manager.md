<!-- source-hash: b89a452c66ab2e136f3846960e744f83 -->
Manages the execution of installed tools across different platforms, with specialized Windows session handling for running processes in active user sessions.

## Key Components

- **`get_active_user_session()`** - Windows-only function that detects active user sessions by enumerating Windows Terminal Services sessions
- **`launch_process_in_console_session()`** - Windows function to launch processes in the physical console session
- **`launch_process_in_user_session()`** - Windows function to launch processes in active user sessions with proper token handling
- **Helper utilities** - Wide string conversion, session enumeration, and token duplication for Windows process creation

## Usage Example

```rust
// The file appears to be incomplete, but based on the visible code:

#[cfg(windows)]
use crate::tool_run_manager::{get_active_user_session, launch_process_in_user_session};

// Launch a tool in the active user session (Windows)
#[cfg(windows)]
async fn run_tool_in_user_session() -> Result<()> {
    let command_path = "C:\\Program Files\\MyTool\\tool.exe";
    let args = vec!["--config".to_string(), "settings.json".to_string()];
    
    match launch_process_in_user_session(command_path, &args) {
        Ok((pid, handle)) => {
            info!("Tool launched successfully with PID: {}", pid);
            // Process handle can be used for monitoring
            Ok(())
        }
        Err(e) => {
            error!("Failed to launch tool: {}", e);
            Err(e)
        }
    }
}

// Get active user session ID
#[cfg(windows)]
fn check_active_session() -> Option<u32> {
    get_active_user_session()
}
```

The manager integrates with `InstalledToolsService`, `ToolCommandParamsResolver`, and `ToolKillService` to provide complete tool lifecycle management, with sophisticated Windows session handling for running tools in the correct user context.