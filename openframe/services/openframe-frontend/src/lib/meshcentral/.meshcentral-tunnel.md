<!-- source-hash: 071da74c57271d526ce0915f93574b4c -->
A WebSocket-based tunnel implementation for establishing secure communication channels with MeshCentral devices, supporting both terminal sessions and desktop connections with automatic reconnection and protocol management.

## Key Components

**Types:**
- `TunnelState` - Connection states (0: stopped, 1: connecting, 2: open, 3: connected)
- `TunnelOptions` - Configuration options for terminal dimensions and authentication
- `TunnelCallbacks` - Event handlers for data, state changes, and control messages

**Main Class:**
- `MeshTunnel` - Core tunnel implementation with WebSocket management, handshake protocol, and message routing

**Key Methods:**
- `start()` - Initiates WebSocket connection with authentication
- `stop()` - Cleanly closes connection and clears resources  
- `sendText()` / `sendBinary()` - Send data through the tunnel
- `sendCtrl()` - Send control messages for protocol management
- `reconnect()` - Reconnect with handshake reset

## Usage Example

```typescript
const tunnel = new MeshTunnel({
  authCookie: 'your-auth-cookie',
  nodeId: 'target-device-id',
  protocol: 1, // Terminal protocol
  options: { cols: 80, rows: 24 },
  onData: (data) => console.log('Received:', data),
  onStateChange: (state) => console.log('State:', state),
  onConsoleMessage: (msg) => console.log('Console:', msg),
  onRequestPairing: (relayId) => {
    // Send pairing request via control connection
    controlConnection.sendPairing(relayId)
  }
})

tunnel.start()

// Send commands
tunnel.sendText('ls -la\n')

// Clean up
tunnel.stop()
```

The tunnel handles authentication, maintains connection health with ping/pong, and provides automatic reconnection with proper handshake re-initialization.